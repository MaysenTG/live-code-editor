{"version":3,"sources":["../static/js/12.9aebc066.chunk.js","../node_modules/codemirror/mode/xml/xml.js","../node_modules/codemirror/mode/javascript/javascript.js","../node_modules/codemirror/mode/jsx/jsx.js"],"names":["webpackJsonp","31","module","exports","__webpack_require__","mod","CodeMirror","htmlConfig","autoSelfClosers","implicitlyClosed","contextGrabbers","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","allowMissingTagName","defineMode","editorConf","config_","inText","stream","state","chain","parser","tokenize","ch","next","eat","match","inBlock","eatWhile","doctype","type","inTag","ok","baseState","tagName","tagStart","test","inAttribute","stringStartCol","column","quote","closure","eol","isInAttribute","style","terminator","depth","Context","startOfLine","this","prev","context","indent","indented","config","hasOwnProperty","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","current","setStyle","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","indentUnit","defaults","htmlMode","prop","isInText","startState","baseIndent","token","sol","indentation","eatSpace","textAfter","fullLine","Pass","length","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","exec","grabbers","electricInput","blockCommentStart","blockCommentEnd","configuration","helperType","skipAttribute","xmlCurrentTag","name","close","xmlCurrentContext","cx","push","reverse","defineMIME","mimeModes","32","parserConfig","readRegexp","escaped","inSet","ret","tp","cont","content","tokenBase","tokenString","tokenComment","skipToEnd","expressionAllowed","tokenQuasi","peek","wordRE","string","slice","start","isOperatorChar","lexical","word","lastType","keywords","propertyIsEnumerable","kw","jsonldMode","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","indexOf","isTS","m","index","sawSomething","pos","charAt","bracket","brackets","JSLexical","align","info","inScope","varname","trackScope","v","localVars","vars","parseJS","cc","marked","pop","jsonMode","expression","statement","lex","pass","i","arguments","apply","inList","list","register","block","newContext","registerVarScoped","Var","globalVars","inner","isModifier","pushcontext","defaultVars","pushblockcontext","popcontext","pushlex","result","outer","poplex","expect","wanted","exp","value","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","className","enumdef","typename","typeexpr","pattern","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","backUp","continueQuasi","targetNoComma","target","maybeTypeArgs","_","getterSetter","afterprop","maybetype","what","end","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","statementIndent","jsonld","json","typescript","wordCharacters","A","B","C","D","operator","atom","basecolumn","top","firstChar","c","closing","doubleIndentSwitch","blockCommentContinue","lineComment","fold","closeBrackets","skipExpression","StringStream","registerHelper","86","mode","copyContext","copyState","modeConfig","flatXMLIndent","xmlMode","xmlToken","jsToken","xmlContext","jsMode","stop","cur","getMode","base","innerMode"],"mappings":"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","file":"static/js/12.9aebc066.chunk.js","sourcesContent":["webpackJsonp([12,30,86],{\n\n/***/ 31:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(0));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName || \"\";\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n\n\n/***/ }),\n\n/***/ 32:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(0));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n/***/ }),\n\n/***/ 86:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(0), __webpack_require__(31), __webpack_require__(32))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n\n  // Depth means the amount of open braces in JS context, in XML\n  // context 0 means not in tag, 1 means in tag, and 2 means in tag\n  // and js block comment.\n  function Context(state, mode, depth, prev) {\n    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev\n  }\n\n  function copyContext(context) {\n    return new Context(CodeMirror.copyState(context.mode, context.state),\n                       context.mode,\n                       context.depth,\n                       context.prev && copyContext(context.prev))\n  }\n\n  CodeMirror.defineMode(\"jsx\", function(config, modeConfig) {\n    var xmlMode = CodeMirror.getMode(config, {name: \"xml\", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true})\n    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || \"javascript\")\n\n    function flatXMLIndent(state) {\n      var tagName = state.tagName\n      state.tagName = null\n      var result = xmlMode.indent(state, \"\", \"\")\n      state.tagName = tagName\n      return result\n    }\n\n    function token(stream, state) {\n      if (state.context.mode == xmlMode)\n        return xmlToken(stream, state, state.context)\n      else\n        return jsToken(stream, state, state.context)\n    }\n\n    function xmlToken(stream, state, cx) {\n      if (cx.depth == 2) { // Inside a JS /* */ comment\n        if (stream.match(/^.*?\\*\\//)) cx.depth = 1\n        else stream.skipToEnd()\n        return \"comment\"\n      }\n\n      if (stream.peek() == \"{\") {\n        xmlMode.skipAttribute(cx.state)\n\n        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context\n        // If JS starts on same line as tag\n        if (xmlContext && stream.match(/^[^>]*>\\s*$/, false)) {\n          while (xmlContext.prev && !xmlContext.startOfLine)\n            xmlContext = xmlContext.prev\n          // If tag starts the line, use XML indentation level\n          if (xmlContext.startOfLine) indent -= config.indentUnit\n          // Else use JS indentation level\n          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented\n        // Else if inside of tag\n        } else if (cx.depth == 1) {\n          indent += config.indentUnit\n        }\n\n        state.context = new Context(CodeMirror.startState(jsMode, indent),\n                                    jsMode, 0, state.context)\n        return null\n      }\n\n      if (cx.depth == 1) { // Inside of tag\n        if (stream.peek() == \"<\") { // Tag inside of tag\n          xmlMode.skipAttribute(cx.state)\n          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),\n                                      xmlMode, 0, state.context)\n          return null\n        } else if (stream.match(\"//\")) {\n          stream.skipToEnd()\n          return \"comment\"\n        } else if (stream.match(\"/*\")) {\n          cx.depth = 2\n          return token(stream, state)\n        }\n      }\n\n      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop\n      if (/\\btag\\b/.test(style)) {\n        if (/>$/.test(cur)) {\n          if (cx.state.context) cx.depth = 0\n          else state.context = state.context.prev\n        } else if (/^</.test(cur)) {\n          cx.depth = 1\n        }\n      } else if (!style && (stop = cur.indexOf(\"{\")) > -1) {\n        stream.backUp(cur.length - stop)\n      }\n      return style\n    }\n\n    function jsToken(stream, state, cx) {\n      if (stream.peek() == \"<\" && jsMode.expressionAllowed(stream, cx.state)) {\n        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, \"\", \"\")),\n                                    xmlMode, 0, state.context)\n        jsMode.skipExpression(cx.state)\n        return null\n      }\n\n      var style = jsMode.token(stream, cx.state)\n      if (!style && cx.depth != null) {\n        var cur = stream.current()\n        if (cur == \"{\") {\n          cx.depth++\n        } else if (cur == \"}\") {\n          if (--cx.depth == 0) state.context = state.context.prev\n        }\n      }\n      return style\n    }\n\n    return {\n      startState: function() {\n        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}\n      },\n\n      copyState: function(state) {\n        return {context: copyContext(state.context)}\n      },\n\n      token: token,\n\n      indent: function(state, textAfter, fullLine) {\n        return state.context.mode.indent(state.context.state, textAfter, fullLine)\n      },\n\n      innerMode: function(state) {\n        return state.context\n      }\n    }\n  }, \"xml\", \"javascript\")\n\n  CodeMirror.defineMIME(\"text/jsx\", \"jsx\")\n  CodeMirror.defineMIME(\"text/typescript-jsx\", {name: \"jsx\", base: {name: \"javascript\", typescript: true}})\n});\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/12.9aebc066.chunk.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName || \"\";\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/mode/xml/xml.js\n// module id = 31\n// module chunks = 0 1 2 3 4 5 6 7 8 9 11 12 15 30","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/mode/javascript/javascript.js\n// module id = 32\n// module chunks = 0 1 2 3 4 5 6 7 8 9 12 16 86","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../javascript/javascript\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n\n  // Depth means the amount of open braces in JS context, in XML\n  // context 0 means not in tag, 1 means in tag, and 2 means in tag\n  // and js block comment.\n  function Context(state, mode, depth, prev) {\n    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev\n  }\n\n  function copyContext(context) {\n    return new Context(CodeMirror.copyState(context.mode, context.state),\n                       context.mode,\n                       context.depth,\n                       context.prev && copyContext(context.prev))\n  }\n\n  CodeMirror.defineMode(\"jsx\", function(config, modeConfig) {\n    var xmlMode = CodeMirror.getMode(config, {name: \"xml\", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true})\n    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || \"javascript\")\n\n    function flatXMLIndent(state) {\n      var tagName = state.tagName\n      state.tagName = null\n      var result = xmlMode.indent(state, \"\", \"\")\n      state.tagName = tagName\n      return result\n    }\n\n    function token(stream, state) {\n      if (state.context.mode == xmlMode)\n        return xmlToken(stream, state, state.context)\n      else\n        return jsToken(stream, state, state.context)\n    }\n\n    function xmlToken(stream, state, cx) {\n      if (cx.depth == 2) { // Inside a JS /* */ comment\n        if (stream.match(/^.*?\\*\\//)) cx.depth = 1\n        else stream.skipToEnd()\n        return \"comment\"\n      }\n\n      if (stream.peek() == \"{\") {\n        xmlMode.skipAttribute(cx.state)\n\n        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context\n        // If JS starts on same line as tag\n        if (xmlContext && stream.match(/^[^>]*>\\s*$/, false)) {\n          while (xmlContext.prev && !xmlContext.startOfLine)\n            xmlContext = xmlContext.prev\n          // If tag starts the line, use XML indentation level\n          if (xmlContext.startOfLine) indent -= config.indentUnit\n          // Else use JS indentation level\n          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented\n        // Else if inside of tag\n        } else if (cx.depth == 1) {\n          indent += config.indentUnit\n        }\n\n        state.context = new Context(CodeMirror.startState(jsMode, indent),\n                                    jsMode, 0, state.context)\n        return null\n      }\n\n      if (cx.depth == 1) { // Inside of tag\n        if (stream.peek() == \"<\") { // Tag inside of tag\n          xmlMode.skipAttribute(cx.state)\n          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),\n                                      xmlMode, 0, state.context)\n          return null\n        } else if (stream.match(\"//\")) {\n          stream.skipToEnd()\n          return \"comment\"\n        } else if (stream.match(\"/*\")) {\n          cx.depth = 2\n          return token(stream, state)\n        }\n      }\n\n      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop\n      if (/\\btag\\b/.test(style)) {\n        if (/>$/.test(cur)) {\n          if (cx.state.context) cx.depth = 0\n          else state.context = state.context.prev\n        } else if (/^</.test(cur)) {\n          cx.depth = 1\n        }\n      } else if (!style && (stop = cur.indexOf(\"{\")) > -1) {\n        stream.backUp(cur.length - stop)\n      }\n      return style\n    }\n\n    function jsToken(stream, state, cx) {\n      if (stream.peek() == \"<\" && jsMode.expressionAllowed(stream, cx.state)) {\n        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, \"\", \"\")),\n                                    xmlMode, 0, state.context)\n        jsMode.skipExpression(cx.state)\n        return null\n      }\n\n      var style = jsMode.token(stream, cx.state)\n      if (!style && cx.depth != null) {\n        var cur = stream.current()\n        if (cur == \"{\") {\n          cx.depth++\n        } else if (cur == \"}\") {\n          if (--cx.depth == 0) state.context = state.context.prev\n        }\n      }\n      return style\n    }\n\n    return {\n      startState: function() {\n        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}\n      },\n\n      copyState: function(state) {\n        return {context: copyContext(state.context)}\n      },\n\n      token: token,\n\n      indent: function(state, textAfter, fullLine) {\n        return state.context.mode.indent(state.context.state, textAfter, fullLine)\n      },\n\n      innerMode: function(state) {\n        return state.context\n      }\n    }\n  }, \"xml\", \"javascript\")\n\n  CodeMirror.defineMIME(\"text/jsx\", \"jsx\")\n  CodeMirror.defineMIME(\"text/typescript-jsx\", {name: \"jsx\", base: {name: \"javascript\", typescript: true}})\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/mode/jsx/jsx.js\n// module id = 86\n// module chunks = 12"],"sourceRoot":""}