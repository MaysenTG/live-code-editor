{"version":3,"sources":["../static/js/86.b3a98fd6.chunk.js","../node_modules/codemirror/mode/javascript/javascript.js"],"names":["webpackJsonp","32","module","exports","__webpack_require__","mod","CodeMirror","defineMode","config","parserConfig","readRegexp","stream","next","escaped","inSet","ret","tp","style","cont","type","content","tokenBase","state","ch","tokenize","tokenString","match","test","eat","tokenComment","skipToEnd","expressionAllowed","current","tokenQuasi","peek","eatWhile","wordRE","string","slice","start","isOperatorChar","lexical","word","lastType","keywords","propertyIsEnumerable","kw","quote","jsonldMode","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","indexOf","isTS","m","exec","index","depth","sawSomething","pos","charAt","bracket","brackets","JSLexical","indented","column","align","prev","info","this","inScope","varname","trackScope","v","localVars","name","cx","context","vars","parseJS","cc","marked","hasOwnProperty","length","pop","jsonMode","expression","statement","lex","pass","i","arguments","push","apply","inList","list","register","block","newContext","registerVarScoped","Var","globalVars","inner","Context","isModifier","pushcontext","defaultVars","pushblockcontext","popcontext","pushlex","result","indent","outer","poplex","expect","wanted","exp","value","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","className","enumdef","typename","typeexpr","pattern","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","backUp","continueQuasi","targetNoComma","target","maybeTypeArgs","_","getterSetter","afterprop","maybetype","what","end","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","textAfter","indentUnit","statementIndent","jsonld","json","typescript","wordCharacters","A","B","C","D","operator","atom","startState","basecolumn","token","sol","indentation","eatSpace","Pass","top","firstChar","c","closing","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","fold","closeBrackets","helperType","skipExpression","StringStream","registerHelper","defineMIME"],"mappings":"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","file":"static/js/86.b3a98fd6.chunk.js","sourcesContent":["webpackJsonp([86],{\n\n/***/ 32:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(0));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/86.b3a98fd6.chunk.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/mode/javascript/javascript.js\n// module id = 32\n// module chunks = 0 1 2 3 4 5 6 7 8 9 12 16 86"],"sourceRoot":""}