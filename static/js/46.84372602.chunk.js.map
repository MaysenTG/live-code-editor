{"version":3,"sources":["../static/js/46.84372602.chunk.js","../node_modules/codemirror/mode/swift/swift.js"],"names":["webpackJsonp","128","module","exports","__webpack_require__","mod","CodeMirror","wordSet","words","set","i","length","tokenBase","stream","state","prev","sol","indented","indentation","eatSpace","ch","peek","match","skipToEnd","tokenize","push","tokenComment","instruction","attribute","binary","octal","hexadecimal","decimal","property","operators","indexOf","next","punc","stringMatch","tokenString","bind","identifier","ident","current","types","hasOwnProperty","atoms","keywords","definingKeywords","tokenUntilClosingParen","depth","inner","backUp","pop","openQuote","singleLine","escaped","eat","Context","align","this","pushContext","column","context","popContext","defineMode","config","startState","token","style","bracket","exec","indent","textAfter","cx","closing","test","indentUnit","electricInput","lineComment","blockCommentStart","blockCommentEnd","fold","closeBrackets","defineMIME"],"mappings":"AAAAA,cAAc,KAERC,IACA,SAAUC,EAAQC,EAASC,ICEjC,SAAUC,GAENA,EAAI,EAAQ,KAKb,SAASC,GACV,YAEA,SAASC,GAAQC,GAEf,IAAK,GADDC,MACKC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,IAAKD,EAAID,EAAME,KAAM,CACvD,OAAOD,GA0BT,QAASG,GAAUC,EAAQC,EAAOC,GAEhC,GADIF,EAAOG,QAAOF,EAAMG,SAAWJ,EAAOK,eACtCL,EAAOM,WAAY,MAAO,KAE9B,IAAIC,GAAKP,EAAOQ,MAChB,IAAU,KAAND,EAAW,CACb,GAAIP,EAAOS,MAAM,MAEf,MADAT,GAAOU,YACA,SAET,IAAIV,EAAOS,MAAM,MAEf,MADAR,GAAMU,SAASC,KAAKC,GACbA,EAAab,EAAQC,GAGhC,GAAID,EAAOS,MAAMK,GAAc,MAAO,SACtC,IAAId,EAAOS,MAAMM,GAAY,MAAO,WACpC,IAAIf,EAAOS,MAAMO,GAAS,MAAO,QACjC,IAAIhB,EAAOS,MAAMQ,GAAQ,MAAO,QAChC,IAAIjB,EAAOS,MAAMS,GAAc,MAAO,QACtC,IAAIlB,EAAOS,MAAMU,GAAU,MAAO,QAClC,IAAInB,EAAOS,MAAMW,GAAW,MAAO,UACnC,IAAIC,EAAUC,QAAQf,IAAO,EAE3B,MADAP,GAAOuB,OACA,UAET,IAAIC,EAAKF,QAAQf,IAAO,EAGtB,MAFAP,GAAOuB,OACPvB,EAAOS,MAAM,MACN,aAET,IAAIgB,EACJ,IAAIA,EAAczB,EAAOS,MAAM,aAAc,CAC3C,GAAIE,GAAWe,EAAYC,KAAK,KAAMF,EAAY,GAElD,OADAxB,GAAMU,SAASC,KAAKD,GACbA,EAASX,EAAQC,GAG1B,GAAID,EAAOS,MAAMmB,GAAa,CAC5B,GAAIC,GAAQ7B,EAAO8B,SACnB,OAAIC,GAAMC,eAAeH,GAAe,aACpCI,EAAMD,eAAeH,GAAe,OACpCK,EAASF,eAAeH,IACtBM,EAAiBH,eAAeH,KAClC5B,EAAMC,KAAO,UACR,WAEG,UAARA,EAAyB,MACtB,WAIT,MADAF,GAAOuB,OACA,KAGT,QAASa,KACP,GAAIC,GAAQ,CACZ,OAAO,UAASrC,EAAQC,EAAOC,GAC7B,GAAIoC,GAAQvC,EAAUC,EAAQC,EAAOC,EACrC,IAAa,eAAToC,EACF,GAAwB,KAApBtC,EAAO8B,YAAoBO,MAC1B,IAAwB,KAApBrC,EAAO8B,UAAkB,CAChC,GAAa,GAATO,EAGF,MAFArC,GAAOuC,OAAO,GACdtC,EAAMU,SAAS6B,MACRvC,EAAMU,SAASV,EAAMU,SAASb,OAAS,GAAGE,EAAQC,KAEpDoC,EAGX,MAAOC,IAIX,QAASZ,GAAYe,EAAWzC,EAAQC,GAGtC,IAFA,GACIM,GADAmC,EAAiC,GAApBD,EAAU3C,OACnB6C,GAAU,EACXpC,EAAKP,EAAOQ,QACjB,GAAImC,EAAS,CAEX,GADA3C,EAAOuB,OACG,KAANhB,EAEF,MADAN,GAAMU,SAASC,KAAKwB,KACb,QAETO,IAAU,MACL,IAAI3C,EAAOS,MAAMgC,GAEtB,MADAxC,GAAMU,SAAS6B,MACR,QAEPxC,GAAOuB,OACPoB,EAAgB,MAANpC,EAMd,MAHImC,IACFzC,EAAMU,SAAS6B,MAEV,SAGT,QAAS3B,GAAab,EAAQC,GAE5B,IADA,GAAIM,KACS,CAGX,GAFAP,EAAOS,MAAM,WAAW,KACxBF,EAAKP,EAAOuB,QACH,KACE,OAAPhB,GAAcP,EAAO4C,IAAI,KAC3B3C,EAAMU,SAASC,KAAKC,GACJ,MAAPN,GAAcP,EAAO4C,IAAI,MAClC3C,EAAMU,SAAS6B,MAGnB,MAAO,UAGT,QAASK,GAAQ3C,EAAM4C,EAAO1C,GAC5B2C,KAAK7C,KAAOA,EACZ6C,KAAKD,MAAQA,EACbC,KAAK3C,SAAWA,EAGlB,QAAS4C,GAAY/C,EAAOD,GAC1B,GAAI8C,GAAQ9C,EAAOS,MAAM,oBAAoB,GAAS,KAAOT,EAAOiD,SAAW,CAC/EhD,GAAMiD,QAAU,GAAIL,GAAQ5C,EAAMiD,QAASJ,EAAO7C,EAAMG,UAG1D,QAAS+C,GAAWlD,GACdA,EAAMiD,UACRjD,EAAMG,SAAWH,EAAMiD,QAAQ9C,SAC/BH,EAAMiD,QAAUjD,EAAMiD,QAAQhD,MAvJlC,GAAIgC,GAAWxC,GAAS,IAAI,MAAM,MAAM,QAAQ,OAAO,YAAY,SAAS,WAAW,SAAS,OAAO,YAAY,iBAC3F,OAAO,SAAS,WAAW,cAAc,UAAU,SAAS,OAAO,MAAM,WAAW,OAAO,YAAY,QACvG,cAAc,UAAU,QAAQ,WAAW,OAAO,WAAW,SAAS,UAAU,gBAAgB,kBAAkB,OAAO,KAAK,KAC9H,QAAQ,OAAO,WAAW,UAAU,OAAO,cAAc,MAAM,QAAQ,KAAK,KAAK,SAAS,SAAS,QAAQ,QAC3G,QAAQ,SAAS,QAAQ,WAAW,cAAc,QAAQ,KAAK,WAAW,QAAQ,SAAS,MAAM,SAAS,MAAM,MAAM,UACtH,aAAa,gBAAgB,QAAQ,OAAO,OAAO,WAAW,UAAU,aAAa,kBAAkB,SAAS,QAChH,MAAM,YAAY,OAAO,cAAc,OAAO,WAAW,aAAa,WAAW,eAAe,aACpHyC,EAAmBzC,GAAS,MAAM,MAAM,QAAQ,OAAO,YAAY,SAAS,WAAW,SAAS,OAAO,YAAY,iBAAiB,QACpIuC,EAAQvC,GAAS,OAAO,QAAQ,MAAM,OAAO,QAAQ,MACrDqC,EAAQrC,GAAS,QAAQ,OAAO,YAAY,aAAa,SAAS,QAAQ,MAAM,OAAO,QAAQ,QAAQ,QAAQ,QAAQ,WAAW,MAAM,SACvH,QAAQ,SAAS,SAAS,SAAS,SACpD2B,EAAY,iBACZG,EAAO,aACPR,EAAS,mBACTC,EAAQ,qBACRC,EAAc,gFACdC,EAAU,kDACVS,EAAa,uCACbR,EAAW,6CACXN,EAAc,eACdC,EAAY,2CAuIhBtB,GAAW2D,WAAW,QAAS,SAASC,GACtC,OACEC,WAAY,WACV,OACEpD,KAAM,KACNgD,QAAS,KACT9C,SAAU,EACVO,cAIJ4C,MAAO,SAASvD,EAAQC,GACtB,GAAIC,GAAOD,EAAMC,IACjBD,GAAMC,KAAO,IACb,IAAIS,GAAWV,EAAMU,SAASV,EAAMU,SAASb,OAAS,IAAMC,EACxDyD,EAAQ7C,EAASX,EAAQC,EAAOC,EAIpC,IAHKsD,GAAkB,WAATA,EACJvD,EAAMC,OAAMD,EAAMC,KAAOsD,GADDvD,EAAMC,KAAOA,EAGlC,eAATsD,EAAwB,CAC1B,GAAIC,GAAU,sBAAsBC,KAAK1D,EAAO8B,UAC5C2B,KAAUA,EAAQ,GAAKN,EAAaH,GAAa/C,EAAOD,GAG9D,MAAOwD,IAGTG,OAAQ,SAAS1D,EAAO2D,GACtB,GAAIC,GAAK5D,EAAMiD,OACf,KAAKW,EAAI,MAAO,EAChB,IAAIC,GAAU,YAAYC,KAAKH,EAC/B,OAAgB,OAAZC,EAAGf,MAAsBe,EAAGf,OAASgB,EAAU,EAAI,GAChDD,EAAGzD,UAAY0D,EAAU,EAAIT,EAAOW,aAG7CC,cAAe,gBAEfC,YAAa,KACbC,kBAAmB,KACnBC,gBAAiB,KACjBC,KAAM,QACNC,cAAe,oBAInB7E,EAAW8E,WAAW,eAAe","file":"static/js/46.84372602.chunk.js","sourcesContent":["webpackJsonp([46],{\n\n/***/ 128:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Swift mode created by Michael Kaminsky https://github.com/mkaminsky11\n\n(function(mod) {\n  if (true)\n    mod(__webpack_require__(0))\n  else if (typeof define == \"function\" && define.amd)\n    define([\"../../lib/codemirror\"], mod)\n  else\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n\n  function wordSet(words) {\n    var set = {}\n    for (var i = 0; i < words.length; i++) set[words[i]] = true\n    return set\n  }\n\n  var keywords = wordSet([\"_\",\"var\",\"let\",\"class\",\"enum\",\"extension\",\"import\",\"protocol\",\"struct\",\"func\",\"typealias\",\"associatedtype\",\n                          \"open\",\"public\",\"internal\",\"fileprivate\",\"private\",\"deinit\",\"init\",\"new\",\"override\",\"self\",\"subscript\",\"super\",\n                          \"convenience\",\"dynamic\",\"final\",\"indirect\",\"lazy\",\"required\",\"static\",\"unowned\",\"unowned(safe)\",\"unowned(unsafe)\",\"weak\",\"as\",\"is\",\n                          \"break\",\"case\",\"continue\",\"default\",\"else\",\"fallthrough\",\"for\",\"guard\",\"if\",\"in\",\"repeat\",\"switch\",\"where\",\"while\",\n                          \"defer\",\"return\",\"inout\",\"mutating\",\"nonmutating\",\"catch\",\"do\",\"rethrows\",\"throw\",\"throws\",\"try\",\"didSet\",\"get\",\"set\",\"willSet\",\n                          \"assignment\",\"associativity\",\"infix\",\"left\",\"none\",\"operator\",\"postfix\",\"precedence\",\"precedencegroup\",\"prefix\",\"right\",\n                          \"Any\",\"AnyObject\",\"Type\",\"dynamicType\",\"Self\",\"Protocol\",\"__COLUMN__\",\"__FILE__\",\"__FUNCTION__\",\"__LINE__\"])\n  var definingKeywords = wordSet([\"var\",\"let\",\"class\",\"enum\",\"extension\",\"import\",\"protocol\",\"struct\",\"func\",\"typealias\",\"associatedtype\",\"for\"])\n  var atoms = wordSet([\"true\",\"false\",\"nil\",\"self\",\"super\",\"_\"])\n  var types = wordSet([\"Array\",\"Bool\",\"Character\",\"Dictionary\",\"Double\",\"Float\",\"Int\",\"Int8\",\"Int16\",\"Int32\",\"Int64\",\"Never\",\"Optional\",\"Set\",\"String\",\n                       \"UInt8\",\"UInt16\",\"UInt32\",\"UInt64\",\"Void\"])\n  var operators = \"+-/*%=|&<>~^?!\"\n  var punc = \":;,.(){}[]\"\n  var binary = /^\\-?0b[01][01_]*/\n  var octal = /^\\-?0o[0-7][0-7_]*/\n  var hexadecimal = /^\\-?0x[\\dA-Fa-f][\\dA-Fa-f_]*(?:(?:\\.[\\dA-Fa-f][\\dA-Fa-f_]*)?[Pp]\\-?\\d[\\d_]*)?/\n  var decimal = /^\\-?\\d[\\d_]*(?:\\.\\d[\\d_]*)?(?:[Ee]\\-?\\d[\\d_]*)?/\n  var identifier = /^\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1/\n  var property = /^\\.(?:\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1)/\n  var instruction = /^\\#[A-Za-z]+/\n  var attribute = /^@(?:\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1)/\n  //var regexp = /^\\/(?!\\s)(?:\\/\\/)?(?:\\\\.|[^\\/])+\\//\n\n  function tokenBase(stream, state, prev) {\n    if (stream.sol()) state.indented = stream.indentation()\n    if (stream.eatSpace()) return null\n\n    var ch = stream.peek()\n    if (ch == \"/\") {\n      if (stream.match(\"//\")) {\n        stream.skipToEnd()\n        return \"comment\"\n      }\n      if (stream.match(\"/*\")) {\n        state.tokenize.push(tokenComment)\n        return tokenComment(stream, state)\n      }\n    }\n    if (stream.match(instruction)) return \"builtin\"\n    if (stream.match(attribute)) return \"attribute\"\n    if (stream.match(binary)) return \"number\"\n    if (stream.match(octal)) return \"number\"\n    if (stream.match(hexadecimal)) return \"number\"\n    if (stream.match(decimal)) return \"number\"\n    if (stream.match(property)) return \"property\"\n    if (operators.indexOf(ch) > -1) {\n      stream.next()\n      return \"operator\"\n    }\n    if (punc.indexOf(ch) > -1) {\n      stream.next()\n      stream.match(\"..\")\n      return \"punctuation\"\n    }\n    var stringMatch\n    if (stringMatch = stream.match(/(\"\"\"|\"|')/)) {\n      var tokenize = tokenString.bind(null, stringMatch[0])\n      state.tokenize.push(tokenize)\n      return tokenize(stream, state)\n    }\n\n    if (stream.match(identifier)) {\n      var ident = stream.current()\n      if (types.hasOwnProperty(ident)) return \"variable-2\"\n      if (atoms.hasOwnProperty(ident)) return \"atom\"\n      if (keywords.hasOwnProperty(ident)) {\n        if (definingKeywords.hasOwnProperty(ident))\n          state.prev = \"define\"\n        return \"keyword\"\n      }\n      if (prev == \"define\") return \"def\"\n      return \"variable\"\n    }\n\n    stream.next()\n    return null\n  }\n\n  function tokenUntilClosingParen() {\n    var depth = 0\n    return function(stream, state, prev) {\n      var inner = tokenBase(stream, state, prev)\n      if (inner == \"punctuation\") {\n        if (stream.current() == \"(\") ++depth\n        else if (stream.current() == \")\") {\n          if (depth == 0) {\n            stream.backUp(1)\n            state.tokenize.pop()\n            return state.tokenize[state.tokenize.length - 1](stream, state)\n          }\n          else --depth\n        }\n      }\n      return inner\n    }\n  }\n\n  function tokenString(openQuote, stream, state) {\n    var singleLine = openQuote.length == 1\n    var ch, escaped = false\n    while (ch = stream.peek()) {\n      if (escaped) {\n        stream.next()\n        if (ch == \"(\") {\n          state.tokenize.push(tokenUntilClosingParen())\n          return \"string\"\n        }\n        escaped = false\n      } else if (stream.match(openQuote)) {\n        state.tokenize.pop()\n        return \"string\"\n      } else {\n        stream.next()\n        escaped = ch == \"\\\\\"\n      }\n    }\n    if (singleLine) {\n      state.tokenize.pop()\n    }\n    return \"string\"\n  }\n\n  function tokenComment(stream, state) {\n    var ch\n    while (true) {\n      stream.match(/^[^/*]+/, true)\n      ch = stream.next()\n      if (!ch) break\n      if (ch === \"/\" && stream.eat(\"*\")) {\n        state.tokenize.push(tokenComment)\n      } else if (ch === \"*\" && stream.eat(\"/\")) {\n        state.tokenize.pop()\n      }\n    }\n    return \"comment\"\n  }\n\n  function Context(prev, align, indented) {\n    this.prev = prev\n    this.align = align\n    this.indented = indented\n  }\n\n  function pushContext(state, stream) {\n    var align = stream.match(/^\\s*($|\\/[\\/\\*])/, false) ? null : stream.column() + 1\n    state.context = new Context(state.context, align, state.indented)\n  }\n\n  function popContext(state) {\n    if (state.context) {\n      state.indented = state.context.indented\n      state.context = state.context.prev\n    }\n  }\n\n  CodeMirror.defineMode(\"swift\", function(config) {\n    return {\n      startState: function() {\n        return {\n          prev: null,\n          context: null,\n          indented: 0,\n          tokenize: []\n        }\n      },\n\n      token: function(stream, state) {\n        var prev = state.prev\n        state.prev = null\n        var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase\n        var style = tokenize(stream, state, prev)\n        if (!style || style == \"comment\") state.prev = prev\n        else if (!state.prev) state.prev = style\n\n        if (style == \"punctuation\") {\n          var bracket = /[\\(\\[\\{]|([\\]\\)\\}])/.exec(stream.current())\n          if (bracket) (bracket[1] ? popContext : pushContext)(state, stream)\n        }\n\n        return style\n      },\n\n      indent: function(state, textAfter) {\n        var cx = state.context\n        if (!cx) return 0\n        var closing = /^[\\]\\}\\)]/.test(textAfter)\n        if (cx.align != null) return cx.align - (closing ? 1 : 0)\n        return cx.indented + (closing ? 0 : config.indentUnit)\n      },\n\n      electricInput: /^\\s*[\\)\\}\\]]$/,\n\n      lineComment: \"//\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      fold: \"brace\",\n      closeBrackets: \"()[]{}''\\\"\\\"``\"\n    }\n  })\n\n  CodeMirror.defineMIME(\"text/x-swift\",\"swift\")\n});\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/46.84372602.chunk.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Swift mode created by Michael Kaminsky https://github.com/mkaminsky11\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd)\n    define([\"../../lib/codemirror\"], mod)\n  else\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n\n  function wordSet(words) {\n    var set = {}\n    for (var i = 0; i < words.length; i++) set[words[i]] = true\n    return set\n  }\n\n  var keywords = wordSet([\"_\",\"var\",\"let\",\"class\",\"enum\",\"extension\",\"import\",\"protocol\",\"struct\",\"func\",\"typealias\",\"associatedtype\",\n                          \"open\",\"public\",\"internal\",\"fileprivate\",\"private\",\"deinit\",\"init\",\"new\",\"override\",\"self\",\"subscript\",\"super\",\n                          \"convenience\",\"dynamic\",\"final\",\"indirect\",\"lazy\",\"required\",\"static\",\"unowned\",\"unowned(safe)\",\"unowned(unsafe)\",\"weak\",\"as\",\"is\",\n                          \"break\",\"case\",\"continue\",\"default\",\"else\",\"fallthrough\",\"for\",\"guard\",\"if\",\"in\",\"repeat\",\"switch\",\"where\",\"while\",\n                          \"defer\",\"return\",\"inout\",\"mutating\",\"nonmutating\",\"catch\",\"do\",\"rethrows\",\"throw\",\"throws\",\"try\",\"didSet\",\"get\",\"set\",\"willSet\",\n                          \"assignment\",\"associativity\",\"infix\",\"left\",\"none\",\"operator\",\"postfix\",\"precedence\",\"precedencegroup\",\"prefix\",\"right\",\n                          \"Any\",\"AnyObject\",\"Type\",\"dynamicType\",\"Self\",\"Protocol\",\"__COLUMN__\",\"__FILE__\",\"__FUNCTION__\",\"__LINE__\"])\n  var definingKeywords = wordSet([\"var\",\"let\",\"class\",\"enum\",\"extension\",\"import\",\"protocol\",\"struct\",\"func\",\"typealias\",\"associatedtype\",\"for\"])\n  var atoms = wordSet([\"true\",\"false\",\"nil\",\"self\",\"super\",\"_\"])\n  var types = wordSet([\"Array\",\"Bool\",\"Character\",\"Dictionary\",\"Double\",\"Float\",\"Int\",\"Int8\",\"Int16\",\"Int32\",\"Int64\",\"Never\",\"Optional\",\"Set\",\"String\",\n                       \"UInt8\",\"UInt16\",\"UInt32\",\"UInt64\",\"Void\"])\n  var operators = \"+-/*%=|&<>~^?!\"\n  var punc = \":;,.(){}[]\"\n  var binary = /^\\-?0b[01][01_]*/\n  var octal = /^\\-?0o[0-7][0-7_]*/\n  var hexadecimal = /^\\-?0x[\\dA-Fa-f][\\dA-Fa-f_]*(?:(?:\\.[\\dA-Fa-f][\\dA-Fa-f_]*)?[Pp]\\-?\\d[\\d_]*)?/\n  var decimal = /^\\-?\\d[\\d_]*(?:\\.\\d[\\d_]*)?(?:[Ee]\\-?\\d[\\d_]*)?/\n  var identifier = /^\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1/\n  var property = /^\\.(?:\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1)/\n  var instruction = /^\\#[A-Za-z]+/\n  var attribute = /^@(?:\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1)/\n  //var regexp = /^\\/(?!\\s)(?:\\/\\/)?(?:\\\\.|[^\\/])+\\//\n\n  function tokenBase(stream, state, prev) {\n    if (stream.sol()) state.indented = stream.indentation()\n    if (stream.eatSpace()) return null\n\n    var ch = stream.peek()\n    if (ch == \"/\") {\n      if (stream.match(\"//\")) {\n        stream.skipToEnd()\n        return \"comment\"\n      }\n      if (stream.match(\"/*\")) {\n        state.tokenize.push(tokenComment)\n        return tokenComment(stream, state)\n      }\n    }\n    if (stream.match(instruction)) return \"builtin\"\n    if (stream.match(attribute)) return \"attribute\"\n    if (stream.match(binary)) return \"number\"\n    if (stream.match(octal)) return \"number\"\n    if (stream.match(hexadecimal)) return \"number\"\n    if (stream.match(decimal)) return \"number\"\n    if (stream.match(property)) return \"property\"\n    if (operators.indexOf(ch) > -1) {\n      stream.next()\n      return \"operator\"\n    }\n    if (punc.indexOf(ch) > -1) {\n      stream.next()\n      stream.match(\"..\")\n      return \"punctuation\"\n    }\n    var stringMatch\n    if (stringMatch = stream.match(/(\"\"\"|\"|')/)) {\n      var tokenize = tokenString.bind(null, stringMatch[0])\n      state.tokenize.push(tokenize)\n      return tokenize(stream, state)\n    }\n\n    if (stream.match(identifier)) {\n      var ident = stream.current()\n      if (types.hasOwnProperty(ident)) return \"variable-2\"\n      if (atoms.hasOwnProperty(ident)) return \"atom\"\n      if (keywords.hasOwnProperty(ident)) {\n        if (definingKeywords.hasOwnProperty(ident))\n          state.prev = \"define\"\n        return \"keyword\"\n      }\n      if (prev == \"define\") return \"def\"\n      return \"variable\"\n    }\n\n    stream.next()\n    return null\n  }\n\n  function tokenUntilClosingParen() {\n    var depth = 0\n    return function(stream, state, prev) {\n      var inner = tokenBase(stream, state, prev)\n      if (inner == \"punctuation\") {\n        if (stream.current() == \"(\") ++depth\n        else if (stream.current() == \")\") {\n          if (depth == 0) {\n            stream.backUp(1)\n            state.tokenize.pop()\n            return state.tokenize[state.tokenize.length - 1](stream, state)\n          }\n          else --depth\n        }\n      }\n      return inner\n    }\n  }\n\n  function tokenString(openQuote, stream, state) {\n    var singleLine = openQuote.length == 1\n    var ch, escaped = false\n    while (ch = stream.peek()) {\n      if (escaped) {\n        stream.next()\n        if (ch == \"(\") {\n          state.tokenize.push(tokenUntilClosingParen())\n          return \"string\"\n        }\n        escaped = false\n      } else if (stream.match(openQuote)) {\n        state.tokenize.pop()\n        return \"string\"\n      } else {\n        stream.next()\n        escaped = ch == \"\\\\\"\n      }\n    }\n    if (singleLine) {\n      state.tokenize.pop()\n    }\n    return \"string\"\n  }\n\n  function tokenComment(stream, state) {\n    var ch\n    while (true) {\n      stream.match(/^[^/*]+/, true)\n      ch = stream.next()\n      if (!ch) break\n      if (ch === \"/\" && stream.eat(\"*\")) {\n        state.tokenize.push(tokenComment)\n      } else if (ch === \"*\" && stream.eat(\"/\")) {\n        state.tokenize.pop()\n      }\n    }\n    return \"comment\"\n  }\n\n  function Context(prev, align, indented) {\n    this.prev = prev\n    this.align = align\n    this.indented = indented\n  }\n\n  function pushContext(state, stream) {\n    var align = stream.match(/^\\s*($|\\/[\\/\\*])/, false) ? null : stream.column() + 1\n    state.context = new Context(state.context, align, state.indented)\n  }\n\n  function popContext(state) {\n    if (state.context) {\n      state.indented = state.context.indented\n      state.context = state.context.prev\n    }\n  }\n\n  CodeMirror.defineMode(\"swift\", function(config) {\n    return {\n      startState: function() {\n        return {\n          prev: null,\n          context: null,\n          indented: 0,\n          tokenize: []\n        }\n      },\n\n      token: function(stream, state) {\n        var prev = state.prev\n        state.prev = null\n        var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase\n        var style = tokenize(stream, state, prev)\n        if (!style || style == \"comment\") state.prev = prev\n        else if (!state.prev) state.prev = style\n\n        if (style == \"punctuation\") {\n          var bracket = /[\\(\\[\\{]|([\\]\\)\\}])/.exec(stream.current())\n          if (bracket) (bracket[1] ? popContext : pushContext)(state, stream)\n        }\n\n        return style\n      },\n\n      indent: function(state, textAfter) {\n        var cx = state.context\n        if (!cx) return 0\n        var closing = /^[\\]\\}\\)]/.test(textAfter)\n        if (cx.align != null) return cx.align - (closing ? 1 : 0)\n        return cx.indented + (closing ? 0 : config.indentUnit)\n      },\n\n      electricInput: /^\\s*[\\)\\}\\]]$/,\n\n      lineComment: \"//\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      fold: \"brace\",\n      closeBrackets: \"()[]{}''\\\"\\\"``\"\n    }\n  })\n\n  CodeMirror.defineMIME(\"text/x-swift\",\"swift\")\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/mode/swift/swift.js\n// module id = 128\n// module chunks = 46"],"sourceRoot":""}