{"version":3,"sources":["../static/js/63.be604b22.chunk.js","../node_modules/codemirror/mode/python/python.js"],"names":["webpackJsonp","42","module","exports","__webpack_require__","mod","CodeMirror","wordRegexp","words","RegExp","join","top","state","scopes","length","wordOperators","commonKeywords","commonBuiltins","registerHelper","concat","defineMode","conf","parserConf","tokenBase","stream","sol","lastToken","indent","indentation","type","scopeOffset","offset","eatSpace","lineOffset","pushPyScope","dedent","peek","errorToken","style","tokenBaseInner","ERRORCLASS","inFormat","match","floatLiteral","eat","intLiteral","stringPrefixes","current","toLowerCase","indexOf","tokenize","formatStringFactory","tokenStringFactory","i","operators","delimiters","identifiers","keywords","builtins","next","delimiter","tokenOuter","tokenNestedExpr","depth","inner","tokenString","eol","eatWhile","singleline","OUTCLASS","singleLineStringErrors","charAt","substr","isString","pop","push","indentUnit","align","pushBracketScope","column","hangingIndent","indented","tokenLexer","beginningOfLine","py3","test","lambda","delimiter_index","slice","singleDelimiters","singleOperators","doubleOperators","doubleDelimiters","tripleDelimiters","splice","myKeywords","myBuiltins","undefined","extra_keywords","extra_builtins","version","Number","startState","basecolumn","token","addErr","textAfter","Pass","scope","closing","electricInput","closeBrackets","triples","lineComment","fold","defineMIME","name","str","split"],"mappings":"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","file":"static/js/63.be604b22.chunk.js","sourcesContent":["webpackJsonp([63],{\n\n/***/ 42:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(0));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                        \"for\", \"from\", \"global\", \"if\", \"import\",\n                        \"lambda\", \"pass\", \"raise\", \"return\",\n                        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                        \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function(conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n    //               (Backwards-compatibility with old, cumbersome config system)\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n                     parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/]\n    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n\n    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined)\n      myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\n    if (parserConf.extra_builtins != undefined)\n      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3)\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                                      \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                                      \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins);\n\n    // tokenizers\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\"\n      if (sol) state.indent = stream.indentation()\n      // Handle scope changes\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset)\n            pushPyScope(state);\n          else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n            state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state))\n            style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state, inFormat) {\n      if (stream.eatSpace()) return null;\n\n      // Handle Comments\n      if (!inFormat && stream.match(/^#.*/)) return \"comment\";\n\n      // Handle Number Literals\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n        if (stream.match(/^[\\d_]+\\.\\d*/)) { floatLiteral = true; }\n        if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n        // Binary\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n        // Octal\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n        // Decimal\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i);\n          // TODO - Can you have imaginary longs?\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      }\n\n      // Handle Strings\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      for (var i = 0; i < operators.length; i++)\n        if (stream.match(operators[i])) return \"operator\"\n\n      if (stream.match(delimiters)) return \"punctuation\";\n\n      if (state.lastToken == \".\" && stream.match(identifiers))\n        return \"property\";\n\n      if (stream.match(keywords) || stream.match(wordOperators))\n        return \"keyword\";\n\n      if (stream.match(builtins))\n        return \"builtin\";\n\n      if (stream.match(/^(self|cls)\\b/))\n        return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\")\n          return \"def\";\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return inFormat ? null :ERRORCLASS;\n    }\n\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenNestedExpr(depth) {\n        return function(stream, state) {\n          var inner = tokenBaseInner(stream, state, true)\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1)\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)\n              else state.tokenize = tokenString\n            }\n          }\n          return inner\n        }\n      }\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0)\n            if (stream.current()) return OUTCLASS;\n            else return state.tokenize(stream, state)\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") state.scopes.pop()\n      state.scopes.push({offset: top(state).offset + conf.indentUnit,\n                         type: \"py\",\n                         align: null})\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^[\\s\\[\\{\\(]*(?:#|$)/, false) ? null : stream.column() + 1\n      state.scopes.push({offset: state.indent + hangingIndent,\n                         type: type,\n                         align: align})\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) {\n        state.beginningOfLine = true;\n        state.dedent = false;\n      }\n\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle decorators\n      if (state.beginningOfLine && current == \"@\")\n        return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n\n      if ((style == \"variable\" || style == \"builtin\")\n          && state.lastToken == \"meta\")\n        style = \"meta\";\n\n      // Handle scope changes.\n      if (current == \"pass\" || current == \"return\")\n        state.dedent = true;\n\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\" && stream.match(/^\\s*(?:#|$)/, false))\n        pushPyScope(state);\n\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1)\n          pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n        delimiter_index = \"])}\".indexOf(current);\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent\n          else return ERRORCLASS;\n        }\n      }\n      if (state.dedent && stream.eol() && top(state).type == \"py\" && state.scopes.length > 1)\n        state.scopes.pop();\n\n      return style;\n    }\n\n    var external = {\n      startState: function(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{offset: basecolumn || 0, type: \"py\", align: null}],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n\n      token: function(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n\n        if (style && style != \"comment\")\n          state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n\n        if (stream.eol() && state.lambda)\n          state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n\n      indent: function(state, textAfter) {\n        if (state.tokenize != tokenBase)\n          return state.tokenize.isString ? CodeMirror.Pass : 0;\n\n        var scope = top(state)\n        var closing = scope.type == textAfter.charAt(0) ||\n            scope.type == \"py\" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter)\n        if (scope.align != null)\n          return scope.align - (closing ? 1 : 0)\n        else\n          return scope.offset - (closing ? hangingIndent : 0)\n      },\n\n      electricInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/,\n      closeBrackets: {triples: \"'\\\"\"},\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function(str) { return str.split(\" \"); };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \"+\n                          \"extern gil include nogil property public \"+\n                          \"readonly struct union DEF IF ELIF ELSE\")\n  });\n\n});\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/63.be604b22.chunk.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                        \"for\", \"from\", \"global\", \"if\", \"import\",\n                        \"lambda\", \"pass\", \"raise\", \"return\",\n                        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                        \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function(conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n    //               (Backwards-compatibility with old, cumbersome config system)\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n                     parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/]\n    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n\n    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined)\n      myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\n    if (parserConf.extra_builtins != undefined)\n      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3)\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                                      \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                                      \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins);\n\n    // tokenizers\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\"\n      if (sol) state.indent = stream.indentation()\n      // Handle scope changes\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset)\n            pushPyScope(state);\n          else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n            state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state))\n            style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state, inFormat) {\n      if (stream.eatSpace()) return null;\n\n      // Handle Comments\n      if (!inFormat && stream.match(/^#.*/)) return \"comment\";\n\n      // Handle Number Literals\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n        if (stream.match(/^[\\d_]+\\.\\d*/)) { floatLiteral = true; }\n        if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n        // Binary\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n        // Octal\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n        // Decimal\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i);\n          // TODO - Can you have imaginary longs?\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      }\n\n      // Handle Strings\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      for (var i = 0; i < operators.length; i++)\n        if (stream.match(operators[i])) return \"operator\"\n\n      if (stream.match(delimiters)) return \"punctuation\";\n\n      if (state.lastToken == \".\" && stream.match(identifiers))\n        return \"property\";\n\n      if (stream.match(keywords) || stream.match(wordOperators))\n        return \"keyword\";\n\n      if (stream.match(builtins))\n        return \"builtin\";\n\n      if (stream.match(/^(self|cls)\\b/))\n        return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\")\n          return \"def\";\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return inFormat ? null :ERRORCLASS;\n    }\n\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenNestedExpr(depth) {\n        return function(stream, state) {\n          var inner = tokenBaseInner(stream, state, true)\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1)\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)\n              else state.tokenize = tokenString\n            }\n          }\n          return inner\n        }\n      }\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0)\n            if (stream.current()) return OUTCLASS;\n            else return state.tokenize(stream, state)\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") state.scopes.pop()\n      state.scopes.push({offset: top(state).offset + conf.indentUnit,\n                         type: \"py\",\n                         align: null})\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^[\\s\\[\\{\\(]*(?:#|$)/, false) ? null : stream.column() + 1\n      state.scopes.push({offset: state.indent + hangingIndent,\n                         type: type,\n                         align: align})\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) {\n        state.beginningOfLine = true;\n        state.dedent = false;\n      }\n\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle decorators\n      if (state.beginningOfLine && current == \"@\")\n        return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n\n      if ((style == \"variable\" || style == \"builtin\")\n          && state.lastToken == \"meta\")\n        style = \"meta\";\n\n      // Handle scope changes.\n      if (current == \"pass\" || current == \"return\")\n        state.dedent = true;\n\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\" && stream.match(/^\\s*(?:#|$)/, false))\n        pushPyScope(state);\n\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1)\n          pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n        delimiter_index = \"])}\".indexOf(current);\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent\n          else return ERRORCLASS;\n        }\n      }\n      if (state.dedent && stream.eol() && top(state).type == \"py\" && state.scopes.length > 1)\n        state.scopes.pop();\n\n      return style;\n    }\n\n    var external = {\n      startState: function(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{offset: basecolumn || 0, type: \"py\", align: null}],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n\n      token: function(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n\n        if (style && style != \"comment\")\n          state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n\n        if (stream.eol() && state.lambda)\n          state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n\n      indent: function(state, textAfter) {\n        if (state.tokenize != tokenBase)\n          return state.tokenize.isString ? CodeMirror.Pass : 0;\n\n        var scope = top(state)\n        var closing = scope.type == textAfter.charAt(0) ||\n            scope.type == \"py\" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter)\n        if (scope.align != null)\n          return scope.align - (closing ? 1 : 0)\n        else\n          return scope.offset - (closing ? hangingIndent : 0)\n      },\n\n      electricInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/,\n      closeBrackets: {triples: \"'\\\"\"},\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function(str) { return str.split(\" \"); };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \"+\n                          \"extern gil include nogil property public \"+\n                          \"readonly struct union DEF IF ELIF ELSE\")\n  });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/codemirror/mode/python/python.js\n// module id = 42\n// module chunks = 10 63"],"sourceRoot":""}